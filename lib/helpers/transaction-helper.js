function TransactionHelper(helper) {
  this._helper = helper;
  this.rawWeb3 = this._helper._ether.web3;
  this._filters = [];
}

TransactionHelper.prototype.createContractInstance = function(name, paramsArray, txnObj) {
  var contractAbi = this._helper._ether.getRegisteredContract(name).abi;
  var contractInstance = this._helper._ether.createContractInstance(name, paramsArray, txnObj);
  contractInstance.__contractName = name;
  var txnHash = contractInstance.transactionHash;
  this._helper.nextStep.needsTxnMined(txnHash);
  this._helper.nextStep.needsContractInstanceReady(contractInstance);
  this._recordTxnHash(txnHash);
  // We can't wrap it yet - see comments in _wrapContractInstance.
  return contractInstance;
};

TransactionHelper.prototype.getRegisteredContractInstanceAt = function(name, address) {
  var contractAbi = this._helper._ether.getRegisteredContract(name).abi;
  // TODO - push down into ether.js
  var contract = this.rawWeb3.eth.contract(contractAbi);
  var contractInstance = contract.at(address);
  contractInstance.__contractName = name;
  this._wrapContractInstance(contractInstance);
  return contractInstance;
};

// Want to spot transactions generated by calling transactions so we can report
// them and ensure we wait for them to be mined before starting the next step.
// We also watch for events generated by the contract - these are great for debugging.
// This is a bit horrible - we can't wrap the contract object straight away since
// web3 won't create the functions until it gets mined - have to call this once we
// detect that has happened (in the back-off-helper!).
// In any case we can only wrap contracts registered with us since need ABI.
// To make life even more complicated, in a multi-node world we need to get hold
// of per-node contract instances - and wrap those too ...
TransactionHelper.prototype._wrapContractInstance = function(contractInstance) {
  if (!contractInstance.__contractName) {
    return;
  }
  if (contractInstance.__wrapped) {
    return;
  }
  this._helper.debug.log('created instance of contract', contractInstance.__contractName, 'at', contractInstance.address);
  var masterNodeNumber = 1;
  var self = this;
  var filter = contractInstance.allEvents(function(error, contractEvent) {
    if (!error) {
      self._helper._emitter.emit('testGeneratedContractEvent', self._helper._wrapper, contractEvent, masterNodeNumber);
    }
  });
  this._filters.push(filter);
  var contractAbi = this._helper._ether.getRegisteredContract(contractInstance.__contractName).abi;
  for (var abiEntryIdx = 0; abiEntryIdx < contractAbi.length; abiEntryIdx++) {
    var abiEntry = contractAbi[abiEntryIdx];
    if (abiEntry.type !== "function" || abiEntry.constant) {
      continue;
    }
    var functionName = abiEntry.name;
    var originalFunction = contractInstance[functionName];
    contractInstance[functionName] = this._makeReplacementFunction(contractInstance, functionName, originalFunction);
  }
  contractInstance.__nodeNumber = masterNodeNumber;
  contractInstance.__wrapped = true;
  // yeah, i guess this could clash with a real contract function, but heyho ...
  contractInstance.node1 = contractInstance;
  for (var nodeNumber = 2; nodeNumber <= this._helper._ether.getNumNodes(); nodeNumber++) {
    contractInstance['node' + nodeNumber] = this._createAndWrapRemoteContractInstance(contractInstance.__contractName, contractAbi, contractInstance.address, nodeNumber);
  }
  return contractInstance;
};

TransactionHelper.prototype._createAndWrapRemoteContractInstance = function(contractName, contractAbi, contractAddress, nodeNumber) {
  var contractInstance = this._helper._ether.getContractInstanceAt(contractAbi, contractAddress, nodeNumber);
  contractInstance.__contractName = contractName;
  contractInstance.__wrapped = true;
  contractInstance.__nodeNumber = nodeNumber;
  this._helper.debug.log('got remote instance of contract', contractInstance.__contractName, 'at', contractInstance.address, 'on node', nodeNumber);
  var self = this;
  var filter = contractInstance.allEvents(function(error, contractEvent) {
    if (!error) {
      self._helper._emitter.emit('testGeneratedContractEvent', self._helper._wrapper, contractEvent, nodeNumber);
    }
  });
  this._filters.push(filter);
  for (var abiEntryIdx = 0; abiEntryIdx < contractAbi.length; abiEntryIdx++) {
    var abiEntry = contractAbi[abiEntryIdx];
    if (abiEntry.type !== "function" || abiEntry.constant) {
      continue;
    }
    var functionName = abiEntry.name;
    var originalFunction = contractInstance[functionName];
    contractInstance[functionName] = this._makeReplacementFunction(contractInstance, functionName, originalFunction);
  }
  return contractInstance;
};

TransactionHelper.prototype._makeReplacementFunction = function(contractInstance, functionName, originalFunction) {
  var self = this;
  var replacementFunction = function() {
    // TODO - more structured instrumentation
    self._helper.debug.log('called contract function', contractInstance.__contractName + '.' + functionName + ' on node ' + contractInstance.__nodeNumber);
    var params = Array.prototype.slice.call(arguments);
    // think this is right, this is the this chosen by the contract instance caller
    var result = originalFunction.apply(this, params);
    // non-constant functions should return txnHashes ...
    var txnHash = result;
    self._helper.nextStep.needsTxnMined(txnHash);
    self._recordTxnHash(result);
    return result;
  };
  return replacementFunction;
};

TransactionHelper.prototype.send = function(txnObj) {
  var txnHash = this._helper._ether.send(txnObj);
  this._helper.nextStep.needsTxnMined(txnHash);
};

TransactionHelper.prototype.recordOtherTxn = function(txnHash) {
  this._recordTxnHash(txnHash);
};

TransactionHelper.prototype._recordTxnHash = function(txnHash) {
  this._helper._emitter.emit('testGeneratedTransaction', this._helper._wrapper, txnHash);
};

TransactionHelper.prototype.getLatestBlockTime = function() {
  return this._helper._ether.getLatestBlockTime();
};

TransactionHelper.prototype._cleanup = function() {
  // important or our script won't exit while we still have watches!
  this._filters.forEach(function (f) { f.stopWatching(); });
};

exports = module.exports = TransactionHelper;
